N=4
W=5
# メモ用配列
DP = [
  [-1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1]
]



def rec(i, j)
  #p DP
  print("i=#{i} j=#{j} \n")
  print("#{DP[i][j]}\n")
  # 重さの配列
  w = [2, 1, 3, 2]
  # 価値の配列
  v = [3, 2, 4, 2]
  # DPのその位置に値が入っていればその値を返す
  if DP[i][j] >= 0
    return DP[i][j]
  end
  # 番号がNなら
  if i == N
    res = 0

  # この荷物が入らない場合
  elsif j < w[i]
    # 再帰的...!

    res = rec(i+1, j)
  else
    # ・この荷物を加算する　・ここは飛ばして次に行くか 結果としてどちらが大きいか
    # この行がメソッドの挙動(出口など)を見えづらくしている。
    res = [rec(i+1, j), rec(i+1, j-w[i])+v[i]].max
  end
  print("this: #{i}, #{j}, #{DP[i][j]} res:#{res}  \n")
  # 以上の分岐が終わったら, DP[i][j]にresを代入
  return DP[i][j] = res
end
# rec を抜けるのはいつ?   --


p rec(0, W)
p DP
