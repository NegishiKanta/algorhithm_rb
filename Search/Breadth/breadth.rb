def bfs
  inf = 1000000000
  # P = que
  que = []

  # pair
  n = 10
  m = 10

  maze = [
    ["#", "S", "#", "#", "#", "#", "#", "#", ".", "#"],
    [".", ".", ".", ".", ".", ".", "#", ".", ".", "#"],
    [".", "#", ".", "#", "#", ".", "#", "#", ".", "#"],
    [".", "#", ".", ".", ".", ".", ".", ".", ".", "."],
    ["#", "#", ".", "#", "#", ".", "#", "#", "#", "#"],
    [".", ".", ".", ".", "#", ".", ".", ".", ".", "#"],
    [".", "#", "#", "#", "#", "#", "#", "#", ".", "#"],
    [".", ".", ".", ".", "#", ".", ".", ".", ".", "."],
    [".", "#", "#", "#", "#", ".", "#", "#", "#", "."],
    [".", ".", ".", ".", "#", ".", ".", ".", "G", "#"]
  ]

  # sx, sy はスタート地点
  sx = 1
  sy = 0
  # gx, gyはゴール地点
  gx = 8
  gy = 9
  # 移動4方向のベクトル
  dx = [1, 0, -1, 0]
  dy = [0, 1, 0, -1]

  # d = [ [],...x10 ]
  d = Array.new
  10.times do
    d << Array.new(10, inf)
  end

    # スタート地点をキューに入れる
    que.push([sx, sy])
    # その点の距離を0にする
    #d[0][0] = 0
    d[sx][sy] = 0

    # queがからになるまでループ
    while que.size > 0
      # キューの先頭を取り出す
      p = que.pop

      # 取り出した状態がゴールなら探索やめる
      if p[0] == gx && p[1] == gy
        break
      end

      for i in 0..3 do
        # 4方向のうち一つに移動後の点(nx, ny)
        nx = p[0] + dx[i]
        ny = p[1] + dy[i]
        print("nx, ny = #{nx} : #{ny}\n")
        # 移動できるかどうかの判定
        # 移動先座標は0以上 & m, mより小さい & # でない
        if 0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == inf
            # 可能移動先保存キューに追加
            que.push([nx, ny])
            # d[移動先]に距離を加算
            d[nx][ny] = d[p[0]][p[1]] + 1
              #p d
        end
      end
      p que
    end
    return d[gy][gx]
end

p bfs()
